##################################################
## Day 3. IPM output                            ##
## Uses; IPM for acai (Euterpe precatoria)      ##
## Analyses: growth, elastiity, harvesting      ##
##################################################

# Clean workspace
rm(list = ls()) # Empty workspace 
#setwd("C:/Users/Zuide015/OneDrive - Wageningen University & Research/Pieter/Teaching/IPM course/2025 Fortaleza IPM/Day3_Wednesday")

# Packages
install.packages(reshape2)
library(dplyr)
library(nlme)
library(ipmr)
library(popbio)
library(popdemo)
library(reshape2)
library(tidyr) 
library(ggplot2)

# Load all data from Exercise_B
#load(file="C:/Users/Zuide015/OneDrive - Wageningen University & Research/Pieter/Teaching/IPM course/2025 Fortaleza IPM/Day2_Tuesday/IPM_construction_acai.Rdata")

load("IPM_construction_acai.Rdata")

########################################
# Step 1. Asymptotic population growth #
########################################

# Option 1. Asymptotic population growth rate, using impr package, which uses projections
ipmr::lambda(eut_ipm) # we specify the ipmr package here to avoid comfusion with the popbio package
conv_plot(eut_ipm)

# Option 2. Asymptotic population growth rate, using the popdemo package, analytical approach 
# First we get the matrix out of the object generated by ipmr
eut_ipm_mat <- as.matrix(eut_ipm$sub_kernels$P[1:mesh,1:mesh]+eut_ipm$sub_kernels$F[1:mesh,1:mesh])
popbio::lambda(eut_ipm_mat)

###################################
# Step 2. Dominant eigen vectors  #
###################################

# Stable size distribution (right eigenvector)
eut_SSD <- right_ev(eut_ipm,iterations=2000)

ggplot() +
  geom_density(data=dff, aes(x=size),col="blue", linewidth=1) + 
  geom_line(aes(x = brks_hist[-1],y=eut_SSD$ht_w),col="darkgreen",linewidth=1) +
  scale_y_continuous(limits = c(0,0.08)) +
  labs(y = "Relative density",x = "Palm height (m)")



ggplot() +
  geom_density(data=dff, aes(x=size),col="blue", linewidth=1) + 
  geom_line(aes(x = brks_hist[-1],y=eut_SSD$ht_w),col="darkgreen",linewidth=1) +
  scale_y_continuous(limits = c(0,0.08)) +
  labs(y = "Relative density",x = "Palm height (m)")



breaks_subset<-brks_hist[c(100:200)]

range(breaks_subset)


filter(dff,size>min(breaks_subset))
range(filter(dff,size>min(breaks_subset))$size)       


sum(eut_SSD$ht_w)
sum((eut_SSD$ht_w[c(100:200)]/sum(eut_SSD$ht_w[c(100:200)])))
range(eut_SSD$ht_w[c(100:200)])
range(eut_SSD)

new_eut_SSD<-(eut_SSD$ht_w[c(100:200)]/sum(eut_SSD$ht_w[c(100:200)]))

ggplot() +
  geom_density(data=filter(dff,size>min(breaks_subset)), aes(x=size),col="blue", linewidth=1) + 
  geom_line(aes(x = brks_hist[c(100:200)],y=new_eut_SSD),col="darkgreen",linewidth=1) +
  #  scale_y_continuous(limits = c(0,0.08)) +
  labs(y = "Relative density",x = "Palm height (m)")



ggplot() +
  geom_density(data=filter(dff,size>min(breaks_subset)), aes(x=size),col="blue", linewidth=1) + 
  geom_line(aes(x = brks_hist[c(100:200)],y=eut_SSD$ht_w[c(100:200)]),col="darkgreen",linewidth=1) +
#  scale_y_continuous(limits = c(0,0.08)) +
  labs(y = "Relative density",x = "Palm height (m)")


length(eut_SSD$ht_w[c(100:200)])
       
length(brks_hist[c(101:200)])

# Reproductive values
eut_RV <- left_ev(eut_ipm,iterations=2000)
plot(y=eut_RV$ht_v,x = brks_hist[-1], main = "Reproductive values", xlab = "Palm height (m)",ylab = "Reproductive value")

###################################
# Step 3. Elasticity analysis     #
###################################

# Calculating an elasticity matrix to determine which transitions contribute most to population growth
# Using popdemo function 'elas' 
eut_elas <- elas(eut_ipm_mat)
sum(eut_elas)


# Adicionei o grÃ¡fico da elasticidade
ggplot(ipm_to_df(eut_elas)) + 
  geom_tile(aes(x=t,y=t_1,fill = value)) + 
  scale_fill_gradient2(low="grey70", high="blue")+
  scale_y_reverse(expand=c(0,0))+
  scale_x_continuous(expand=c(0,0))+
  labs(y = "Class number at time t+1",x = "Class number at time t")


# To plot in ggplot, convert to dataframe
eut_elas_df <- reshape2::melt(eut_elas, c("x", "y"), value.name = "z")

ggplot(eut_elas_df) + 
  geom_tile(aes(x=x,y=y,fill = z)) + 
  scale_y_reverse()+
  scale_fill_gradient2(low="grey70", high="blue")+
  labs(y = "Class number at time t+1",x = "Class number at time t")

ggplot(data.frame(colSums(eut_elas))) + 
  geom_line(aes(x=brks_hist[-1],y=colSums.eut_elas.),col="blue",linewidth=1) + 
  labs(y = "Elasticty per class",x = "Palm height (m)")

# Elasticity for F and P kernels
elas_F <- sum(eut_elas[1:10,30:200])
elas_P <- sum(eut_elas) - elas_F

elas_F
elas_P
###################################
# Step 4. Age estimations     #
###################################

# From the IPM, we can calculate the time it takes for an average recruit to 
# produce offspring
generation.time(eut_ipm_mat)

###################################
# Step 5. Projections in time     #
###################################

# ipmr conducts population projections, but we will not use these because they are relative abundances  
# We create our own simulations of the population over time: transient population dynamics

# Project the IPM for 100 years
tmax <- 120

# These are matrices to store the results of the simulations
ProjDistr <- matrix(NA,nrow=mesh,ncol=tmax+1)
ProjDistr[,1] <- srt_distr$counts

# This is the transient population distribution
transdistr <- srt_distr$counts

for (t in 1:tmax) {
  transdistr <- eut_ipm_mat %*% transdistr
  ProjDistr[,t+1] <- transdistr
  }

# Plot the population development over time
# First calculate total population size

eut_pop_size <- data.frame(colSums(ProjDistr)) %>% 
  mutate(time=0:tmax)
colnames(eut_pop_size)[1] <- "pop_size_unharvested"

ggplot(eut_pop_size) + 
  geom_line(aes(x=0:tmax,y=pop_size_unharvested ),col="blue",linewidth=1) + 
  labs(y = "Population abundance (ind / 6 ha)",x = "Year during simultaion") +
  scale_y_continuous(limits = c(0,800))
  
# Plot the development of large palms (>17 m) over time
eut_large_unhar <- ProjDistr[which(round(brks_hist,1)==17.0):mesh,] %>% 
  colSums() %>% 
  data.frame %>% 
  mutate(time=1:(tmax+1))
colnames(eut_large_unhar)[1] <- "pop_large_unharvested"

ggplot(eut_large_unhar) + 
  geom_line(aes(x=0:tmax,y=pop_large_unharvested),col="blue",linewidth=1) + 
  labs(y = "Population abundance (ind / 6 ha)",x = "Year during simultaion") +
  scale_y_continuous(limits = c(0,150))

##################################
# Step 6. Harvest simulations    #
##################################

# Next we can perform harvest simulations
# Set simulation time, first category of harvesting and proportion harvested
cyclen=      20    # length of harvest cycle
nrcyc=        4    # max number of harvest cycles
harvint=      0.9  # proportion of individuals harvested
firstharcat=  which(round(brks_hist,1)==17.0) # check in what class palms are 2 m tall
lastharcat=   mesh  # final harvesting category

# Make a harvesting vector.   
harvstr <- matrix(1,nrow=mesh,ncol=1)
harvstr[firstharcat:lastharcat] <- 1-harvint 

# Create  matrices for output
ProjDistrHar <- matrix(0,nrow=mesh,ncol=1)
PalmsHarvested <- matrix(0,nrow=nrcyc,ncol=1)

# Set starting structure and copy to output matrices
transdistr <- srt_distr$counts
ProjDistrHar[,1] <- srt_distr$counts

# Harvest simulations
for (cyc in 1:nrcyc) {
  PalmsHarvested[cyc] <- sum(transdistr) - sum(transdistr * harvstr)
  transdistr <- transdistr * harvstr
  for (tcyc in 1:cyclen) {
    transdistr <- eut_ipm_mat %*% transdistr
    ProjDistrHar <- cbind(ProjDistrHar,transdistr)
  }
}

# Make a plot of the population development, and compare with the development of the unhatrvested population 
# First add results of harvest simulation to eut_large_ind 
eut_pop_combined <- eut_pop_size[1:length(colSums(ProjDistrHar)),] %>% 
  mutate(pop_size_harvested=colSums(ProjDistrHar)) %>% 
  pivot_longer(cols=c(pop_size_unharvested, pop_size_harvested),names_to="Simulation",values_to="Abundance",names_prefix = "pop_large_")

ggplot(eut_pop_combined) + 
  geom_line(aes(x=time,y=Abundance, col=Simulation),linewidth=1) + 
  labs(y = "Population abundance (ind / 6 ha)",x = "Year during simultaion") +
  scale_y_continuous(limits = c(0,500))

# And one of the number of harvested palms
eut_large_combined <- eut_large_unhar[1:length(colSums(ProjDistrHar)),] %>% 
  mutate(pop_large_harvested=colSums(ProjDistrHar[firstharcat:lastharcat,])) %>% 
  pivot_longer(cols=c(pop_large_unharvested, pop_large_harvested),names_to="Simulation",values_to="Abundance",names_prefix = "pop_large_")

ggplot(eut_large_combined) + 
  geom_line(aes(x=time,y=Abundance, col=Simulation),linewidth=1) + 
  labs(y = "Abundance harvestable individuals (ind / 6 ha)",x = "Year during simultaion") +
  scale_y_continuous(limits = c(0,150))

